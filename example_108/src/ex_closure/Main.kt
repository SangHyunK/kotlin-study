package ex_closure

// [클로저] : 선언 될 당시 상황을 기억하는 함수
// 클로저라는 것을 이용하면 지역 변수가 소멸하지 않는 것처럼 보이게 할 수 있다

// () -> Unit 타입의 함수를 반환하는 returnFunc 함수를 선언하고 있다
fun returnFunc(num: Int): () -> Unit = { println(num) }
fun main() {

    // returnFunc 함수가 반환한 함수를 f 참조 변수에 저장하고 있다
    val f: () -> Unit = returnFunc(30)

    // f 가 가리키고 있는 함수를 호출한다, 30이 출력된다
    f()

    // 이 코드에서 이상한 점을 눈치채지 못했나? 네.....
    // f 를 호출하면 println(num)을 호출하는 데 f 를 호출한 시점에는 이미 num 이라는 변수는 이미 사라지고 없다
    // returnFunc 함수 호출이 끝난 순간 매개변수도 같이 사라지기 때문에...

    // 이게 가능한 이유는 리터럴 함수가 자신이 만들어 질 때의 상황을 기억하고 있기 때문이다
    // 함수 리터럴은 자기 주변 상황을 함께 저장함. 즉, 함수가 만들어 질 때 num 매개변수의 값을 복사해 가지고 있는다
}